<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite Sheet Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }

        h1 {
            margin: 0 0 20px 0;
            color: #fff;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .main-panel {
            background: #16213e;
            border-radius: 10px;
            padding: 20px;
        }

        .side-panel {
            background: #16213e;
            border-radius: 10px;
            padding: 20px;
        }

        .sprite-container {
            position: relative;
            overflow: auto;
            background: #0f0f23;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 20px;
            max-height: 400px;
        }

        #spriteCanvas {
            display: block;
            cursor: crosshair;
        }

        .sprite-toolbar {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .preview-section {
            background: #0f0f23;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }

        .preview-section h3 {
            margin: 0 0 15px 0;
            color: #4ecca3;
        }

        #previewCanvas {
            background: #2a2a4a;
            border-radius: 4px;
            image-rendering: pixelated;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        button {
            background: #4ecca3;
            color: #1a1a2e;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.2s;
        }

        button:hover {
            background: #3db892;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: #4a4a6a;
            color: #fff;
        }

        button.secondary:hover {
            background: #5a5a7a;
        }

        button.danger {
            background: #e74c3c;
            color: #fff;
        }

        button.danger:hover {
            background: #c0392b;
        }

        .play-btn {
            background: #e74c3c;
            font-size: 16px;
            padding: 12px 30px;
        }

        .play-btn.playing {
            background: #27ae60;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 12px;
            text-transform: uppercase;
        }

        input[type="number"], input[type="range"], input[type="file"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #4a4a6a;
            border-radius: 4px;
            background: #0f0f23;
            color: #fff;
            font-size: 14px;
        }

        input[type="range"] {
            padding: 0;
            margin: 10px 0;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .frame-list {
            max-height: 300px;
            overflow-y: auto;
            margin: 15px 0;
        }

        .frame-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: #0f0f23;
            border-radius: 4px;
            margin-bottom: 5px;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .frame-item:hover {
            background: #1a1a3e;
        }

        .frame-item.selected {
            border-color: #4ecca3;
        }

        .frame-item canvas {
            border-radius: 2px;
            background: #2a2a4a;
        }

        .frame-item span {
            flex: 1;
        }

        .frame-item .delete-btn {
            background: transparent;
            color: #e74c3c;
            padding: 5px 10px;
            font-size: 12px;
        }

        .frame-item .dupe-btn {
            background: transparent;
            color: #4ecca3;
            padding: 5px 10px;
            font-size: 12px;
        }

        .frame-actions {
            display: flex;
            gap: 2px;
        }

        .mode-toggle {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .mode-toggle button {
            flex: 1;
            padding: 8px;
            font-size: 12px;
        }

        .mode-toggle button.active {
            background: #4ecca3;
            color: #1a1a2e;
        }

        .mode-toggle button:not(.active) {
            background: #4a4a6a;
            color: #fff;
        }

        .stamp-info {
            background: #0f0f23;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 12px;
            color: #888;
            text-align: center;
        }

        .stamp-info.active {
            background: rgba(78, 204, 163, 0.2);
            color: #4ecca3;
            border: 1px solid #4ecca3;
        }

        .status {
            text-align: center;
            padding: 10px;
            color: #888;
            font-size: 14px;
        }

        .drop-zone {
            border: 2px dashed #4a4a6a;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.2s;
        }

        .drop-zone.dragover {
            border-color: #4ecca3;
            background: rgba(78, 204, 163, 0.1);
        }

        .drop-zone p {
            margin: 0 0 10px 0;
            color: #888;
        }

        .info {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .section-title {
            font-size: 14px;
            color: #4ecca3;
            margin: 20px 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #4a4a6a;
        }

        .frame-coords {
            font-size: 11px;
            color: #666;
        }

        #downloadBtn {
            width: 100%;
            margin-top: 10px;
        }

        .keyboard-hint {
            font-size: 11px;
            color: #666;
            margin-top: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Sprite Sheet Editor</h1>

    <div class="container">
        <div class="main-panel">
            <div class="drop-zone" id="dropZone">
                <p>Drop sprite sheet image here or click to browse</p>
                <input type="file" id="fileInput" accept="image/*" style="display: none;">
                <button onclick="document.getElementById('fileInput').click()">Choose File</button>
            </div>

            <div class="sprite-container" id="spriteContainer" style="display: none;">
                <div class="sprite-toolbar">
                    <button class="secondary" onclick="openNewImage()">üìÅ Open New Image</button>
                    <span id="imageName" style="color: #888; font-size: 12px; margin-left: 10px;"></span>
                </div>
                <canvas id="spriteCanvas"></canvas>
            </div>

            <div class="preview-section">
                <h3>Animation Preview</h3>
                <canvas id="previewCanvas" width="200" height="200"></canvas>
                <div id="frameIndicator" style="font-size: 18px; font-weight: bold; color: #4ecca3; margin-bottom: 10px;">
                    Frame 0 / 0
                </div>
                <div class="controls">
                    <button class="play-btn" id="playBtn" onclick="togglePlay()">‚ñ∂ Play</button>
                    <button class="secondary" onclick="stepFrame(-1)">‚óÄ Prev</button>
                    <button class="secondary" onclick="stepFrame(1)">Next ‚ñ∂</button>
                </div>
                <div class="input-group" style="margin-top: 15px;">
                    <label>Speed: <span id="speedValue">100</span>ms per frame</label>
                    <input type="range" id="speedSlider" min="30" max="500" value="100" onchange="updateSpeed()">
                </div>
                <div class="input-group">
                    <label>Preview Scale</label>
                    <input type="range" id="scaleSlider" min="1" max="4" value="2" step="0.5" onchange="updateScale()">
                </div>
                <div class="keyboard-hint">
                    Space: Play | ‚Üê‚Üí: Step | 1/V: Select | 2/G: Grid | 3/D: Draw | 4/S: Stamp | 5/B: BG | ‚åòZ: Undo
                </div>
            </div>
        </div>

        <div class="side-panel">
            <div class="section-title">Edit Mode</div>

            <div class="mode-toggle">
                <button id="modeSelect" class="active" onclick="setMode('select')">Select</button>
                <button id="modeGrid" onclick="setMode('grid')">Grid</button>
                <button id="modeDraw" onclick="setMode('draw')">Draw</button>
                <button id="modeStamp" onclick="setMode('stamp')">Stamp</button>
                <button id="modeTransparent" onclick="setMode('transparent')">BG</button>
            </div>

            <div class="stamp-info" id="stampInfo">
                Select a frame, then switch to Stamp mode to click and place copies
            </div>

            <div id="transparencyControls" style="display: none; margin-bottom: 15px;">
                <div class="input-group">
                    <label>Color Tolerance: <span id="toleranceValue">30</span></label>
                    <input type="range" id="toleranceSlider" min="0" max="100" value="30" onchange="updateTolerance()">
                </div>
                <button class="secondary" style="width: 100%;" onclick="clearTransparency()">Clear Transparency</button>
            </div>

            <div class="section-title">Frame Settings</div>

            <div class="input-row">
                <div class="input-group">
                    <label>Frame Width</label>
                    <input type="number" id="frameWidth" value="170" min="1" onchange="updateFrameSize()">
                </div>
                <div class="input-group">
                    <label>Frame Height</label>
                    <input type="number" id="frameHeight" value="448" min="1" onchange="updateFrameSize()">
                </div>
            </div>

            <div class="input-group">
                <label>Grid Split (Rows √ó Cols)</label>
                <div class="input-row" style="grid-template-columns: 1fr auto 1fr auto;">
                    <input type="number" id="gridRows" value="1" min="1" max="20" style="text-align: center;">
                    <span style="color: #888; padding: 8px 4px;">√ó</span>
                    <input type="number" id="gridCols" value="6" min="1" max="20" style="text-align: center;">
                    <button class="secondary" onclick="gridSplit()" style="padding: 8px 12px;">Split</button>
                </div>
            </div>

            <div class="section-title">Frames (<span id="frameCount">0</span>)</div>

            <div class="frame-list" id="frameList">
                <div class="status">No frames defined yet.<br>Click on the sprite sheet to add frames.</div>
            </div>

            <button class="secondary" onclick="clearFrames()" style="width: 100%;">Clear All Frames</button>

            <div class="section-title">Import / Export</div>
            <input type="file" id="importJsonInput" accept=".json" style="display: none;" onchange="importFrameData(event)">
            <button class="secondary" style="width: 100%;" onclick="document.getElementById('importJsonInput').click()">Import Frame Data</button>
            <button class="secondary" style="width: 100%; margin-top: 5px;" onclick="exportFrameData()">Export Frame Data</button>
            <button id="downloadBtn" style="width: 100%; margin-top: 5px;" onclick="downloadGif()">Download as GIF</button>
        </div>
    </div>

    <script>
        // State
        let spriteImage = null;
        let currentImageFilename = null;
        let frames = [];
        let selectedFrameIndex = -1;
        let isPlaying = false;
        let currentFrame = 0;
        let animationInterval = null;
        let speed = 100;
        let scale = 2;
        let isSelecting = false;
        let selectionStart = null;
        let currentSelection = null;

        // Interaction modes
        let editMode = 'select'; // 'select', 'draw', 'stamp', 'grid'
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let dragFrameIndex = -1;

        // Grid state
        let gridInfo = null; // { rows, cols, frameWidth, frameHeight, originX, originY }
        let gridResizeMode = null; // 'nw', 'ne', 'sw', 'se', 'n', 's', 'e', 'w', or null
        let gridResizeStart = null; // { x, y, gridInfo, frames }

        // Transparency state
        let transparentColor = null; // { r, g, b }
        let colorTolerance = 30;

        // Undo history
        let history = [];
        let maxHistory = 50;

        function saveState() {
            history.push({
                frames: JSON.parse(JSON.stringify(frames)),
                gridInfo: gridInfo ? JSON.parse(JSON.stringify(gridInfo)) : null,
                selectedFrameIndex: selectedFrameIndex
            });
            if (history.length > maxHistory) {
                history.shift();
            }
        }

        function undo() {
            if (history.length === 0) return;
            const state = history.pop();
            frames = state.frames;
            gridInfo = state.gridInfo;
            selectedFrameIndex = state.selectedFrameIndex;
            updateFrameList();
            drawSpriteSheet();
            drawPreview();
        }

        // Elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const spriteContainer = document.getElementById('spriteContainer');
        const spriteCanvas = document.getElementById('spriteCanvas');
        const spriteCtx = spriteCanvas.getContext('2d');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        const frameList = document.getElementById('frameList');
        const playBtn = document.getElementById('playBtn');

        // File handling
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file, file.name);
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) loadImage(file, file.name);
        });

        function openNewImage() {
            // Reset state for new image
            frames = [];
            gridInfo = null;
            transparentColor = null;
            history = [];
            currentPreviewFrame = 0;

            // Trigger file picker
            fileInput.click();
        }

        function loadImage(file, filename) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    spriteImage = img;
                    spriteCanvas.width = img.width;
                    spriteCanvas.height = img.height;
                    document.getElementById('frameHeight').value = img.height;

                    // Auto-calculate frame width based on count
                    const count = parseInt(document.getElementById('gridCols').value);
                    document.getElementById('frameWidth').value = Math.floor(img.width / count);

                    dropZone.style.display = 'none';
                    spriteContainer.style.display = 'block';

                    // Show and store filename
                    currentImageFilename = filename || null;
                    const imageNameEl = document.getElementById('imageName');
                    if (imageNameEl && filename) {
                        imageNameEl.textContent = filename;
                    }

                    // Reset frames for new image
                    frames = [];
                    gridInfo = null;

                    drawSpriteSheet();
                    updatePreview();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Load default image
        function loadDefaultImage() {
            const img = new Image();
            img.onload = () => {
                spriteImage = img;
                spriteCanvas.width = img.width;
                spriteCanvas.height = img.height;
                document.getElementById('frameHeight').value = img.height;

                const count = parseInt(document.getElementById('gridCols').value);
                document.getElementById('frameWidth').value = Math.floor(img.width / count);

                dropZone.style.display = 'none';
                spriteContainer.style.display = 'block';

                drawSpriteSheet();
            };
            img.onerror = () => {
                console.log('Default image not found, waiting for user upload');
            };
            img.src = 'jude-walk-gemini2.png';
        }

        // Mode management
        function setMode(mode) {
            editMode = mode;
            document.getElementById('modeSelect').classList.toggle('active', mode === 'select');
            document.getElementById('modeGrid').classList.toggle('active', mode === 'grid');
            document.getElementById('modeDraw').classList.toggle('active', mode === 'draw');
            document.getElementById('modeStamp').classList.toggle('active', mode === 'stamp');
            document.getElementById('modeTransparent').classList.toggle('active', mode === 'transparent');

            // Update cursor
            if (mode === 'select') {
                spriteCanvas.style.cursor = 'default';
            } else if (mode === 'grid') {
                spriteCanvas.style.cursor = 'move';
            } else if (mode === 'draw') {
                spriteCanvas.style.cursor = 'crosshair';
            } else if (mode === 'stamp') {
                spriteCanvas.style.cursor = 'copy';
            } else if (mode === 'transparent') {
                spriteCanvas.style.cursor = 'crosshair';
            }

            // Update info text
            const stampInfo = document.getElementById('stampInfo');
            if (mode === 'grid') {
                if (gridInfo) {
                    stampInfo.textContent = `Drag to move entire ${gridInfo.rows}√ó${gridInfo.cols} grid`;
                    stampInfo.classList.add('active');
                } else {
                    stampInfo.textContent = 'Use Grid Split first to create a grid';
                    stampInfo.classList.remove('active');
                }
            } else if (mode === 'transparent') {
                if (transparentColor) {
                    stampInfo.innerHTML = `BG color: <span style="display:inline-block;width:14px;height:14px;background:rgb(${transparentColor.r},${transparentColor.g},${transparentColor.b});border:1px solid #fff;vertical-align:middle;"></span> (tolerance: ${colorTolerance}) - Click to pick new color`;
                    stampInfo.classList.add('active');
                } else {
                    stampInfo.textContent = 'Click on the background color to make it transparent';
                    stampInfo.classList.add('active');
                }
            } else if (mode === 'stamp' && selectedFrameIndex >= 0) {
                const frame = frames[selectedFrameIndex];
                stampInfo.textContent = `Click to place ${frame.width}√ó${frame.height} frame (from Frame ${selectedFrameIndex + 1})`;
                stampInfo.classList.add('active');
            } else if (mode === 'stamp') {
                stampInfo.textContent = 'Select a frame first to use Stamp mode';
                stampInfo.classList.remove('active');
            } else {
                stampInfo.textContent = 'Select a frame, then switch to Stamp mode to click and place copies';
                stampInfo.classList.remove('active');
            }
        }

        // Grid resize helpers
        function getGridBounds() {
            if (!gridInfo || frames.length === 0) return null;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            frames.forEach(f => {
                minX = Math.min(minX, f.x);
                minY = Math.min(minY, f.y);
                maxX = Math.max(maxX, f.x + f.width);
                maxY = Math.max(maxY, f.y + f.height);
            });
            return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
        }

        function getGridResizeHandle(x, y) {
            const bounds = getGridBounds();
            if (!bounds) return null;
            const handleSize = 15;
            const { x: bx, y: by, width: bw, height: bh } = bounds;

            // Corner handles
            if (Math.abs(x - bx) < handleSize && Math.abs(y - by) < handleSize) return 'nw';
            if (Math.abs(x - (bx + bw)) < handleSize && Math.abs(y - by) < handleSize) return 'ne';
            if (Math.abs(x - bx) < handleSize && Math.abs(y - (by + bh)) < handleSize) return 'sw';
            if (Math.abs(x - (bx + bw)) < handleSize && Math.abs(y - (by + bh)) < handleSize) return 'se';

            // Edge handles
            if (Math.abs(y - by) < handleSize && x > bx && x < bx + bw) return 'n';
            if (Math.abs(y - (by + bh)) < handleSize && x > bx && x < bx + bw) return 's';
            if (Math.abs(x - bx) < handleSize && y > by && y < by + bh) return 'w';
            if (Math.abs(x - (bx + bw)) < handleSize && y > by && y < by + bh) return 'e';

            return null;
        }

        function getResizeCursor(handle) {
            const cursors = {
                'nw': 'nwse-resize', 'se': 'nwse-resize',
                'ne': 'nesw-resize', 'sw': 'nesw-resize',
                'n': 'ns-resize', 's': 'ns-resize',
                'e': 'ew-resize', 'w': 'ew-resize'
            };
            return cursors[handle] || 'move';
        }

        // Find if a point is inside a frame
        function findFrameAtPoint(x, y) {
            // Search in reverse so top frames are found first
            for (let i = frames.length - 1; i >= 0; i--) {
                const frame = frames[i];
                if (x >= frame.x && x <= frame.x + frame.width &&
                    y >= frame.y && y <= frame.y + frame.height) {
                    return i;
                }
            }
            return -1;
        }

        // Canvas interaction
        spriteCanvas.addEventListener('mousedown', (e) => {
            const rect = spriteCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (editMode === 'select') {
                // Check if clicking on an existing frame
                const frameIndex = findFrameAtPoint(x, y);
                if (frameIndex >= 0) {
                    saveState(); // Save before dragging
                    // Start dragging
                    isDragging = true;
                    dragFrameIndex = frameIndex;
                    selectedFrameIndex = frameIndex;
                    const frame = frames[frameIndex];
                    dragOffset = { x: x - frame.x, y: y - frame.y };
                    spriteCanvas.style.cursor = 'grabbing';
                    updateFrameList();
                    drawSpriteSheet();
                }
            } else if (editMode === 'grid') {
                // Check for resize handles first
                if (gridInfo && frames.length > 0) {
                    saveState(); // Save before any grid modification
                    const handle = getGridResizeHandle(x, y);
                    if (handle) {
                        gridResizeMode = handle;
                        gridResizeStart = {
                            x: x,
                            y: y,
                            gridInfo: JSON.parse(JSON.stringify(gridInfo)),
                            frames: JSON.parse(JSON.stringify(frames))
                        };
                        spriteCanvas.style.cursor = getResizeCursor(handle);
                    } else {
                        // Start dragging entire grid
                        isDragging = true;
                        dragOffset = { x: x - gridInfo.originX, y: y - gridInfo.originY };
                        spriteCanvas.style.cursor = 'grabbing';
                    }
                }
            } else if (editMode === 'draw') {
                isSelecting = true;
                selectionStart = { x, y };
                currentSelection = null;
            } else if (editMode === 'stamp') {
                // Place a copy of the selected frame at click position
                if (selectedFrameIndex >= 0) {
                    saveState();
                    const sourceFrame = frames[selectedFrameIndex];
                    frames.push({
                        x: Math.round(x - sourceFrame.width / 2),
                        y: Math.round(y - sourceFrame.height / 2),
                        width: sourceFrame.width,
                        height: sourceFrame.height
                    });
                    updateFrameList();
                    drawSpriteSheet();
                }
            } else if (editMode === 'transparent') {
                // Pick color from sprite sheet
                pickTransparentColor(x, y);
            }
        });

        spriteCanvas.addEventListener('mousemove', (e) => {
            const rect = spriteCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (editMode === 'select' && isDragging && dragFrameIndex >= 0) {
                // Drag the frame
                const frame = frames[dragFrameIndex];
                frame.x = Math.max(0, Math.min(spriteCanvas.width - frame.width, Math.round(x - dragOffset.x)));
                frame.y = Math.max(0, Math.min(spriteCanvas.height - frame.height, Math.round(y - dragOffset.y)));
                drawSpriteSheet();
                updateFrameList();
            } else if (editMode === 'select' && !isDragging) {
                // Update cursor based on hover
                const frameIndex = findFrameAtPoint(x, y);
                spriteCanvas.style.cursor = frameIndex >= 0 ? 'grab' : 'default';
            } else if (editMode === 'grid' && gridResizeMode && gridResizeStart) {
                // Resize grid
                const deltaX = x - gridResizeStart.x;
                const deltaY = y - gridResizeStart.y;
                const startBounds = {
                    x: Math.min(...gridResizeStart.frames.map(f => f.x)),
                    y: Math.min(...gridResizeStart.frames.map(f => f.y)),
                    width: gridResizeStart.gridInfo.cols * gridResizeStart.gridInfo.frameWidth,
                    height: gridResizeStart.gridInfo.rows * gridResizeStart.gridInfo.frameHeight
                };

                let scaleX = 1, scaleY = 1, offsetX = 0, offsetY = 0;

                // Calculate scale based on resize handle
                if (gridResizeMode.includes('e')) {
                    scaleX = Math.max(0.1, (startBounds.width + deltaX) / startBounds.width);
                }
                if (gridResizeMode.includes('w')) {
                    scaleX = Math.max(0.1, (startBounds.width - deltaX) / startBounds.width);
                    offsetX = deltaX;
                }
                if (gridResizeMode.includes('s')) {
                    scaleY = Math.max(0.1, (startBounds.height + deltaY) / startBounds.height);
                }
                if (gridResizeMode.includes('n')) {
                    scaleY = Math.max(0.1, (startBounds.height - deltaY) / startBounds.height);
                    offsetY = deltaY;
                }

                // Apply uniform scale for corners
                if (gridResizeMode.length === 2) {
                    const scale = (scaleX + scaleY) / 2;
                    scaleX = scaleY = scale;
                }

                // Update frames
                const newFrameWidth = Math.round(gridResizeStart.gridInfo.frameWidth * scaleX);
                const newFrameHeight = Math.round(gridResizeStart.gridInfo.frameHeight * scaleY);

                gridResizeStart.frames.forEach((startFrame, i) => {
                    const col = i % gridResizeStart.gridInfo.cols;
                    const row = Math.floor(i / gridResizeStart.gridInfo.cols);
                    frames[i].x = Math.round(startBounds.x + offsetX + col * newFrameWidth);
                    frames[i].y = Math.round(startBounds.y + offsetY + row * newFrameHeight);
                    frames[i].width = newFrameWidth;
                    frames[i].height = newFrameHeight;
                });

                gridInfo.frameWidth = newFrameWidth;
                gridInfo.frameHeight = newFrameHeight;
                gridInfo.originX = Math.round(startBounds.x + offsetX);
                gridInfo.originY = Math.round(startBounds.y + offsetY);

                drawSpriteSheet();
                updateFrameList();
            } else if (editMode === 'grid' && isDragging && gridInfo) {
                // Move entire grid
                const newOriginX = Math.round(x - dragOffset.x);
                const newOriginY = Math.round(y - dragOffset.y);
                const deltaX = newOriginX - gridInfo.originX;
                const deltaY = newOriginY - gridInfo.originY;

                // Update all frame positions
                frames.forEach(frame => {
                    frame.x += deltaX;
                    frame.y += deltaY;
                });

                gridInfo.originX = newOriginX;
                gridInfo.originY = newOriginY;

                drawSpriteSheet();
                updateFrameList();
            } else if (editMode === 'grid' && !isDragging && !gridResizeMode) {
                // Update cursor for resize handles
                const handle = getGridResizeHandle(x, y);
                spriteCanvas.style.cursor = handle ? getResizeCursor(handle) : 'move';
            } else if (editMode === 'draw' && isSelecting && selectionStart) {
                currentSelection = {
                    x: Math.min(selectionStart.x, x),
                    y: Math.min(selectionStart.y, y),
                    width: Math.abs(x - selectionStart.x),
                    height: Math.abs(y - selectionStart.y)
                };
                drawSpriteSheet();
            }
        });

        spriteCanvas.addEventListener('mouseup', (e) => {
            if (editMode === 'select' && isDragging) {
                isDragging = false;
                dragFrameIndex = -1;
                spriteCanvas.style.cursor = 'grab';
                updateFrameList(); // Update thumbnails after drag
            } else if (editMode === 'grid' && gridResizeMode) {
                gridResizeMode = null;
                gridResizeStart = null;
                spriteCanvas.style.cursor = 'move';
                updateFrameList();
            } else if (editMode === 'grid' && isDragging) {
                isDragging = false;
                spriteCanvas.style.cursor = 'move';
                updateFrameList();
            } else if (editMode === 'draw' && isSelecting) {
                isSelecting = false;

                if (currentSelection && currentSelection.width > 10 && currentSelection.height > 10) {
                    saveState();
                    // Add the selection as a frame
                    frames.push({
                        x: Math.round(currentSelection.x),
                        y: Math.round(currentSelection.y),
                        width: Math.round(currentSelection.width),
                        height: Math.round(currentSelection.height)
                    });
                    selectedFrameIndex = frames.length - 1;
                    updateFrameList();
                }

                currentSelection = null;
                selectionStart = null;
                drawSpriteSheet();
            }
        });

        spriteCanvas.addEventListener('mouseleave', () => {
            if (isDragging) {
                isDragging = false;
                dragFrameIndex = -1;
                updateFrameList();
            }
        });

        function drawSpriteSheet() {
            if (!spriteImage) return;

            spriteCtx.clearRect(0, 0, spriteCanvas.width, spriteCanvas.height);
            spriteCtx.drawImage(spriteImage, 0, 0);

            // Draw frame guides
            const frameWidth = parseInt(document.getElementById('frameWidth').value);
            spriteCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            spriteCtx.lineWidth = 1;
            for (let x = frameWidth; x < spriteCanvas.width; x += frameWidth) {
                spriteCtx.beginPath();
                spriteCtx.moveTo(x, 0);
                spriteCtx.lineTo(x, spriteCanvas.height);
                spriteCtx.stroke();
            }

            // Draw existing frames
            frames.forEach((frame, i) => {
                spriteCtx.strokeStyle = i === selectedFrameIndex ? '#4ecca3' : '#e74c3c';
                spriteCtx.lineWidth = 2;
                spriteCtx.strokeRect(frame.x, frame.y, frame.width, frame.height);

                // Frame number
                spriteCtx.fillStyle = i === selectedFrameIndex ? '#4ecca3' : '#e74c3c';
                spriteCtx.font = 'bold 16px sans-serif';
                spriteCtx.fillText(i + 1, frame.x + 5, frame.y + 20);
            });

            // Draw current selection
            if (currentSelection) {
                spriteCtx.strokeStyle = '#4ecca3';
                spriteCtx.lineWidth = 2;
                spriteCtx.setLineDash([5, 5]);
                spriteCtx.strokeRect(currentSelection.x, currentSelection.y, currentSelection.width, currentSelection.height);
                spriteCtx.setLineDash([]);
            }
        }

        function updateFrameList() {
            document.getElementById('frameCount').textContent = frames.length;

            if (frames.length === 0) {
                frameList.innerHTML = '<div class="status">No frames defined yet.<br>Click on the sprite sheet to add frames.</div>';
                return;
            }

            frameList.innerHTML = frames.map((frame, i) => {
                const thumbCanvas = document.createElement('canvas');
                thumbCanvas.width = 40;
                thumbCanvas.height = 40;
                const ctx = thumbCanvas.getContext('2d');

                if (spriteImage) {
                    const aspectRatio = frame.width / frame.height;
                    let drawWidth = 40;
                    let drawHeight = 40;
                    if (aspectRatio > 1) {
                        drawHeight = 40 / aspectRatio;
                    } else {
                        drawWidth = 40 * aspectRatio;
                    }
                    const offsetX = (40 - drawWidth) / 2;
                    const offsetY = (40 - drawHeight) / 2;
                    ctx.drawImage(spriteImage, frame.x, frame.y, frame.width, frame.height, offsetX, offsetY, drawWidth, drawHeight);
                }

                return `
                    <div class="frame-item ${i === selectedFrameIndex ? 'selected' : ''}" onclick="selectFrame(${i})">
                        <canvas width="40" height="40" id="thumb_${i}"></canvas>
                        <span>Frame ${i + 1}<br><span class="frame-coords">${frame.x}, ${frame.y} (${frame.width}√ó${frame.height})</span></span>
                        <div class="frame-actions">
                            <button class="dupe-btn" onclick="duplicateFrame(${i}); event.stopPropagation();" title="Duplicate">‚ßâ</button>
                            <button class="delete-btn" onclick="deleteFrame(${i}); event.stopPropagation();" title="Delete">√ó</button>
                        </div>
                    </div>
                `;
            }).join('');

            // Draw thumbnails
            frames.forEach((frame, i) => {
                const thumbCanvas = document.getElementById(`thumb_${i}`);
                if (thumbCanvas && spriteImage) {
                    const ctx = thumbCanvas.getContext('2d');
                    const aspectRatio = frame.width / frame.height;
                    let drawWidth = 40;
                    let drawHeight = 40;
                    if (aspectRatio > 1) {
                        drawHeight = 40 / aspectRatio;
                    } else {
                        drawWidth = 40 * aspectRatio;
                    }
                    const offsetX = (40 - drawWidth) / 2;
                    const offsetY = (40 - drawHeight) / 2;
                    ctx.drawImage(spriteImage, frame.x, frame.y, frame.width, frame.height, offsetX, offsetY, drawWidth, drawHeight);
                }
            });

            drawPreview();
        }

        function selectFrame(index) {
            selectedFrameIndex = index;
            currentFrame = index;
            updateFrameList();
            drawSpriteSheet();
            drawPreview();

            // Update stamp info if in stamp mode
            if (editMode === 'stamp') {
                setMode('stamp');
            }
        }

        function duplicateFrame(index) {
            saveState();
            const sourceFrame = frames[index];
            // Place duplicate slightly offset
            frames.push({
                x: sourceFrame.x + 20,
                y: sourceFrame.y + 20,
                width: sourceFrame.width,
                height: sourceFrame.height
            });
            selectedFrameIndex = frames.length - 1;
            updateFrameList();
            drawSpriteSheet();
        }

        function deleteFrame(index) {
            saveState();
            frames.splice(index, 1);
            if (selectedFrameIndex >= frames.length) {
                selectedFrameIndex = frames.length - 1;
            }
            updateFrameList();
            drawSpriteSheet();
        }

        function clearFrames() {
            frames = [];
            selectedFrameIndex = -1;
            updateFrameList();
            drawSpriteSheet();
        }

        function gridSplit() {
            if (!spriteImage) return;
            saveState();

            const rows = parseInt(document.getElementById('gridRows').value);
            const cols = parseInt(document.getElementById('gridCols').value);
            const frameWidth = Math.floor(spriteImage.width / cols);
            const frameHeight = Math.floor(spriteImage.height / rows);

            document.getElementById('frameWidth').value = frameWidth;
            document.getElementById('frameHeight').value = frameHeight;

            // Store grid info for later adjustment
            gridInfo = {
                rows: rows,
                cols: cols,
                frameWidth: frameWidth,
                frameHeight: frameHeight,
                originX: 0,
                originY: 0
            };

            frames = [];
            // Go row by row, left to right (reading order)
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    frames.push({
                        x: col * frameWidth,
                        y: row * frameHeight,
                        width: frameWidth,
                        height: frameHeight
                    });
                }
            }

            updateFrameList();
            drawSpriteSheet();

            // Auto-switch to grid mode for adjustment
            setMode('grid');
        }

        function updateFrameSize() {
            drawSpriteSheet();
        }

        // Animation
        function drawPreview() {
            const frameIndicator = document.getElementById('frameIndicator');

            if (frames.length === 0 || !spriteImage) {
                previewCtx.fillStyle = '#2a2a4a';
                previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
                previewCtx.fillStyle = '#666';
                previewCtx.font = '14px sans-serif';
                previewCtx.textAlign = 'center';
                previewCtx.fillText('Add frames to preview', previewCanvas.width / 2, previewCanvas.height / 2);
                frameIndicator.textContent = 'Frame 0 / 0';
                return;
            }

            const frameIndex = currentFrame % frames.length;
            const frame = frames[frameIndex];
            frameIndicator.textContent = `Frame ${frameIndex + 1} / ${frames.length}`;

            // Resize canvas to fit frame
            const displayWidth = frame.width * scale;
            const displayHeight = frame.height * scale;
            previewCanvas.width = displayWidth;
            previewCanvas.height = displayHeight;

            previewCtx.imageSmoothingEnabled = false;
            previewCtx.clearRect(0, 0, displayWidth, displayHeight);

            // Draw checkerboard background to show transparency
            if (transparentColor) {
                const checkSize = 8;
                for (let cy = 0; cy < displayHeight; cy += checkSize) {
                    for (let cx = 0; cx < displayWidth; cx += checkSize) {
                        previewCtx.fillStyle = ((cx + cy) / checkSize) % 2 === 0 ? '#ccc' : '#fff';
                        previewCtx.fillRect(cx, cy, checkSize, checkSize);
                    }
                }
            }

            // Draw frame to temp canvas first, then apply transparency
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = frame.width;
            tempCanvas.height = frame.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(
                spriteImage,
                frame.x, frame.y, frame.width, frame.height,
                0, 0, frame.width, frame.height
            );

            // Apply transparency if set
            if (transparentColor) {
                applyTransparency(tempCanvas);
            }

            // Draw to preview canvas with scaling
            previewCtx.drawImage(tempCanvas, 0, 0, displayWidth, displayHeight);
        }

        function togglePlay() {
            if (frames.length === 0) return;

            isPlaying = !isPlaying;
            playBtn.textContent = isPlaying ? '‚è∏ Pause' : '‚ñ∂ Play';
            playBtn.classList.toggle('playing', isPlaying);

            if (isPlaying) {
                animationInterval = setInterval(() => {
                    currentFrame = (currentFrame + 1) % frames.length;
                    drawPreview();
                }, speed);
            } else {
                clearInterval(animationInterval);
            }
        }

        function stepFrame(dir) {
            if (frames.length === 0) return;
            if (isPlaying) togglePlay();
            currentFrame = (currentFrame + dir + frames.length) % frames.length;
            drawPreview();
        }

        function updateSpeed() {
            speed = parseInt(document.getElementById('speedSlider').value);
            document.getElementById('speedValue').textContent = speed;

            if (isPlaying) {
                clearInterval(animationInterval);
                animationInterval = setInterval(() => {
                    currentFrame = (currentFrame + 1) % frames.length;
                    drawPreview();
                }, speed);
            }
        }

        function updateScale() {
            scale = parseFloat(document.getElementById('scaleSlider').value);
            drawPreview();
        }

        // Transparency functions
        function pickTransparentColor(x, y) {
            if (!spriteImage) return;

            // Create a temporary canvas to get pixel data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = spriteImage.width;
            tempCanvas.height = spriteImage.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(spriteImage, 0, 0);

            const pixel = tempCtx.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
            transparentColor = { r: pixel[0], g: pixel[1], b: pixel[2] };

            document.getElementById('transparencyControls').style.display = 'block';
            setMode('transparent'); // Refresh info text

            drawSpriteSheet();
            drawPreview();
        }

        function updateTolerance() {
            colorTolerance = parseInt(document.getElementById('toleranceSlider').value);
            document.getElementById('toleranceValue').textContent = colorTolerance;
            setMode('transparent'); // Refresh info text
            drawPreview();
        }

        function clearTransparency() {
            transparentColor = null;
            document.getElementById('transparencyControls').style.display = 'none';
            setMode('transparent');
            drawPreview();
        }

        function colorDistance(r1, g1, b1, r2, g2, b2) {
            return Math.sqrt((r1-r2)**2 + (g1-g2)**2 + (b1-b2)**2);
        }

        function applyTransparency(canvas) {
            if (!transparentColor) return canvas;

            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const maxDist = colorTolerance * 4.41; // Scale tolerance (0-100 to color distance)

            for (let i = 0; i < data.length; i += 4) {
                const dist = colorDistance(
                    data[i], data[i+1], data[i+2],
                    transparentColor.r, transparentColor.g, transparentColor.b
                );
                if (dist <= maxDist) {
                    data[i+3] = 0; // Set alpha to 0
                }
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // Export
        async function downloadGif() {
            if (frames.length === 0) {
                alert('Add some frames first!');
                return;
            }

            if (typeof GIF === 'undefined') {
                alert('GIF library not loaded. Check your internet connection.');
                return;
            }

            const btn = document.getElementById('downloadBtn');
            const originalText = btn.textContent;
            btn.textContent = 'Creating GIF...';
            btn.disabled = true;

            try {
                const gif = new GIF({
                    workers: 2,
                    quality: 10,
                    width: frames[0].width,
                    height: frames[0].height,
                    workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js'
                });

                // Add each frame
                for (const frame of frames) {
                    const canvas = document.createElement('canvas');
                    canvas.width = frame.width;
                    canvas.height = frame.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(
                        spriteImage,
                        frame.x, frame.y, frame.width, frame.height,
                        0, 0, frame.width, frame.height
                    );
                    // Apply transparency if set
                    applyTransparency(canvas);
                    gif.addFrame(canvas, { delay: speed, transparent: transparentColor ? 0x00FF00 : null });
                }

                gif.on('finished', async function(blob) {
                    btn.textContent = originalText;
                    btn.disabled = false;

                    // Try to use file picker API
                    if (window.showSaveFilePicker) {
                        try {
                            const handle = await window.showSaveFilePicker({
                                suggestedName: 'animation.gif',
                                types: [{
                                    description: 'GIF Image',
                                    accept: { 'image/gif': ['.gif'] }
                                }]
                            });
                            const writable = await handle.createWritable();
                            await writable.write(blob);
                            await writable.close();
                            alert('GIF saved successfully!');
                        } catch (e) {
                            if (e.name !== 'AbortError') {
                                // Fallback to download
                                downloadBlob(blob, 'animation.gif');
                            }
                        }
                    } else {
                        downloadBlob(blob, 'animation.gif');
                    }
                });

                gif.render();
            } catch (e) {
                btn.textContent = originalText;
                btn.disabled = false;
                alert('Error creating GIF: ' + e.message);
            }
        }

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importFrameData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);

                    if (!data.frames || !Array.isArray(data.frames)) {
                        alert('Invalid frame data: missing frames array');
                        return;
                    }

                    saveState(); // Save before importing

                    frames = data.frames;
                    if (data.speed) {
                        speed = data.speed;
                        document.getElementById('speedSlider').value = speed;
                        document.getElementById('speedValue').textContent = speed;
                    }

                    // Try to reconstruct grid info if frames are uniform
                    if (frames.length > 0) {
                        const firstFrame = frames[0];
                        const allSameSize = frames.every(f =>
                            f.width === firstFrame.width && f.height === firstFrame.height
                        );
                        if (allSameSize) {
                            // Detect grid dimensions
                            const cols = new Set(frames.map(f => f.x)).size;
                            const rows = Math.ceil(frames.length / cols);
                            gridInfo = {
                                rows: rows,
                                cols: cols,
                                frameWidth: firstFrame.width,
                                frameHeight: firstFrame.height,
                                originX: Math.min(...frames.map(f => f.x)),
                                originY: Math.min(...frames.map(f => f.y))
                            };
                            document.getElementById('gridRows').value = rows;
                            document.getElementById('gridCols').value = cols;
                            document.getElementById('frameWidth').value = firstFrame.width;
                            document.getElementById('frameHeight').value = firstFrame.height;
                        }
                    }

                    selectedFrameIndex = 0;
                    currentFrame = 0;
                    updateFrameList();
                    drawSpriteSheet();
                    drawPreview();

                    alert(`Imported ${frames.length} frames`);
                } catch (err) {
                    alert('Error parsing JSON: ' + err.message);
                }
            };
            reader.readAsText(file);

            // Reset input so same file can be selected again
            event.target.value = '';
        }

        async function exportFrameData() {
            if (frames.length === 0) {
                alert('No frames to export!');
                return;
            }

            const data = {
                frames: frames,
                speed: speed,
                imageWidth: spriteImage?.width,
                imageHeight: spriteImage?.height,
                imageFile: currentImageFilename
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });

            // Try to use file picker API
            if (window.showSaveFilePicker) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: 'sprite-frames.json',
                        types: [{
                            description: 'JSON File',
                            accept: { 'application/json': ['.json'] }
                        }]
                    });
                    const writable = await handle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    return;
                } catch (e) {
                    if (e.name === 'AbortError') return; // User cancelled
                    // Fallback to download
                }
            }

            downloadBlob(blob, 'sprite-frames.json');
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;

            switch (e.code) {
                case 'Space':
                    e.preventDefault();
                    togglePlay();
                    break;
                case 'ArrowLeft':
                    stepFrame(-1);
                    break;
                case 'ArrowRight':
                    stepFrame(1);
                    break;
                case 'KeyV':
                case 'Digit1':
                    setMode('select');
                    break;
                case 'KeyG':
                case 'Digit2':
                    setMode('grid');
                    break;
                case 'KeyD':
                case 'Digit3':
                    setMode('draw');
                    break;
                case 'KeyS':
                case 'Digit4':
                    setMode('stamp');
                    break;
                case 'KeyB':
                case 'Digit5':
                    setMode('transparent');
                    break;
                case 'Delete':
                case 'Backspace':
                    if (selectedFrameIndex >= 0) {
                        e.preventDefault();
                        deleteFrame(selectedFrameIndex);
                    }
                    break;
                case 'KeyC':
                    if ((e.metaKey || e.ctrlKey) && selectedFrameIndex >= 0) {
                        duplicateFrame(selectedFrameIndex);
                    }
                    break;
                case 'KeyZ':
                    if (e.metaKey || e.ctrlKey) {
                        e.preventDefault();
                        undo();
                    }
                    break;
            }
        });

        // Initialize
        loadDefaultImage();
    </script>
</body>
</html>
